# .github/workflows/reusable-deploy.yml
name: Reusable Swarm Deploy

on:
  workflow_call:
    inputs:
      service_name:
        required: true
        type: string
        description: "Nom du service (tresorerieservice, menuservice, etc.)"
      image_name:
        required: true
        type: string
        description: "Nom de l'image Docker"
      deploy_path:
        required: true
        type: string
        description: "Chemin de dÃ©ploiement sur le serveur"
      compose_file:
        required: true
        type: string
        description: "Nom du fichier docker-compose"
      environment:
        required: true
        type: string
        description: "Environnement (dev ou prod)"
      ssh_port:
        required: false
        type: number
        default: 22
        description: "Port SSH"
      build_workflow_name:
        required: true
        type: string
        description: "Nom du workflow de build pour rÃ©cupÃ©rer le tag"
      stack_name:
        required: false
        type: string
        default: ''
        description: "Nom de la stack Swarm (si diffÃ©rent du service_name)"
      registry:
        required: false
        type: string
        default: 'komanatse'
        description: "Registry Docker Hub"
    secrets:
      SSH_HOST:
        required: true
      SSH_USER:
        required: true
      SSH_PRIVATE_KEY:
        required: true
      SSH_PASSPHRASE:
        required: false
      DOCKERHUB_TOKEN:
        required: true
      ENV_CONTENT:
        required: true

jobs:
  get-version:
    name: Get Version Tag
    runs-on: ubuntu-latest
    permissions:
      actions: read
    outputs:
      version_tag: ${{ steps.get-tag.outputs.version_tag }}
    steps:
      - name: Get version tag from build workflow
        id: get-tag
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # RÃ©cupÃ©rer le dernier run rÃ©ussi du workflow de build
          WORKFLOW_NAME="${{ inputs.build_workflow_name }}"
          
          # Utiliser gh cli pour rÃ©cupÃ©rer les infos du workflow
          RUN_INFO=$(gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/workflows/${WORKFLOW_NAME}.yml/runs?status=success&per_page=1" \
            2>/dev/null || echo '{"workflow_runs":[]}')
          
          # Extraire la date de crÃ©ation
          CREATED_AT=$(echo "$RUN_INFO" | jq -r '.workflow_runs[0].created_at // empty')
          HEAD_BRANCH=$(echo "$RUN_INFO" | jq -r '.workflow_runs[0].head_branch // empty')
          
          if [ -n "$CREATED_AT" ]; then
            # VÃ©rifier si c'est un tag de release (vX.X.X)
            if [[ "$HEAD_BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              VERSION_TAG="$HEAD_BRANCH"
            else
              # GÃ©nÃ©rer le tag Ã  partir de la date du build
              DATE_TAG=$(date -d "$CREATED_AT" +'%Y%m%d-%H%M' 2>/dev/null || date +'%Y%m%d-%H%M')
              VERSION_TAG="dev-$DATE_TAG"
            fi
          else
            # Fallback: utiliser la date actuelle
            DATE_TAG=$(date +'%Y%m%d-%H%M')
            VERSION_TAG="dev-$DATE_TAG"
          fi
          
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Version tag: $VERSION_TAG"

  deploy:
    name: Deploy to ${{ inputs.environment }}
    needs: get-version
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ inputs.ssh_port }}
          script: |
            set -e
            
            SERVICE_NAME="${{ inputs.service_name }}"
            DEPLOY_PATH="${{ inputs.deploy_path }}"
            COMPOSE_FILE="${{ inputs.compose_file }}"
            VERSION_TAG="${{ needs.get-version.outputs.version_tag }}"
            STACK_NAME="${{ inputs.stack_name }}"
            REGISTRY="${{ inputs.registry }}"
            
            # Si stack_name n'est pas dÃ©fini, utiliser service_name sans "service"
            if [ -z "$STACK_NAME" ]; then
              STACK_NAME=$(echo "$SERVICE_NAME" | sed 's/service$//')
            fi
            
            echo "ðŸš€ DÃ©ploiement de $SERVICE_NAME sur ${{ inputs.environment }}"
            echo "ðŸ“¦ Version: $VERSION_TAG"
            echo "ðŸ“ Stack: $STACK_NAME"
            
            # Aller dans le rÃ©pertoire de dÃ©ploiement
            cd "$DEPLOY_PATH"
            
            # CrÃ©er/Mettre Ã  jour le fichier .env
            cat > .env << 'ENVEOF'
            ${{ secrets.ENV_CONTENT }}
            ENVEOF
            
            # Ajouter DOCKER_TAG au .env
            echo "DOCKER_TAG=$VERSION_TAG" >> .env
            
            # Login Docker Hub
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "$REGISTRY" --password-stdin
            
            # Pull les nouvelles images
            echo "ðŸ“¥ Pull des images..."
            docker compose -f "$COMPOSE_FILE" pull --quiet
            
            # GÃ©nÃ©rer le fichier rÃ©solu compatible Swarm
            echo "âš™ï¸ GÃ©nÃ©ration du fichier Swarm..."
            docker compose -f "$COMPOSE_FILE" config | \
              sed 's/published: "\([0-9]*\)"/published: \1/g' | \
              sed '/host_ip:/d' | \
              sed '/^name:/d' > /tmp/stack-resolved.yml
            
            # DÃ©ployer/Mettre Ã  jour la stack
            echo "ðŸ”„ DÃ©ploiement de la stack..."
            docker stack deploy \
              -c /tmp/stack-resolved.yml \
              --with-registry-auth \
              --prune \
              "$STACK_NAME"
            
            # Nettoyer
            rm -f /tmp/stack-resolved.yml
            
            echo "âœ… $SERVICE_NAME dÃ©ployÃ© avec succÃ¨s sur ${{ inputs.environment }}"
            
            # Afficher le statut
            echo ""
            echo "ðŸ“Š Statut des services:"
            sleep 5
            docker service ls --filter "name=${STACK_NAME}_"
            
            # Nettoyer les anciennes images
            docker image prune -f || true

  health-check:
    name: Health Check
    needs: [get-version, deploy]
    runs-on: ubuntu-latest
    steps:
      - name: Wait for services to stabilize
        run: sleep 30
      
      - name: Check service health
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ inputs.ssh_port }}
          script: |
            SERVICE_NAME="${{ inputs.service_name }}"
            STACK_NAME="${{ inputs.stack_name }}"
            
            # Si stack_name n'est pas dÃ©fini, utiliser service_name sans "service"
            if [ -z "$STACK_NAME" ]; then
              STACK_NAME=$(echo "$SERVICE_NAME" | sed 's/service$//')
            fi
            
            echo "ðŸ¥ VÃ©rification de santÃ© de $STACK_NAME..."
            
            # VÃ©rifier que tous les services sont healthy
            UNHEALTHY=$(docker service ls --filter "name=${STACK_NAME}_" --format "{{.Name}} {{.Replicas}}" | grep -v "1/1\|2/2\|0/0" || true)
            
            if [ -n "$UNHEALTHY" ]; then
              echo "âš ï¸ Services en problÃ¨me:"
              echo "$UNHEALTHY"
              
              # Afficher les logs des services en erreur
              echo "$UNHEALTHY" | awk '{print $1}' | while read svc; do
                echo "--- Logs de $svc ---"
                docker service logs --tail 50 "$svc" 2>&1 || true
              done
              
              exit 1
            fi
            
            echo "âœ… Tous les services de $STACK_NAME sont healthy"

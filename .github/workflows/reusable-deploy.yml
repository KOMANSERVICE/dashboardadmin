# .github/workflows/reusable-deploy.yml
name: Reusable Swarm Deploy

on:
  workflow_call:
    inputs:
      service_name:
        required: true
        type: string
        description: "Nom du service (tresorerieservice, menuservice, etc.)"
      image_name:
        required: true
        type: string
        description: "Nom de l'image Docker"
      deploy_path:
        required: true
        type: string
        description: "Chemin de dÃ©ploiement sur le serveur"
      compose_file:
        required: true
        type: string
        description: "Nom du fichier docker-compose"
      environment:
        required: true
        type: string
        description: "Environnement (dev ou prod)"
      ssh_port:
        required: false
        type: number
        default: 22
        description: "Port SSH"
      build_workflow_name:
        required: true
        type: string
        description: "Nom du workflow de build pour rÃ©cupÃ©rer le tag"
      stack_name:
        required: false
        type: string
        default: ''
        description: "Nom de la stack Swarm (si diffÃ©rent du service_name)"
      registry:
        required: false
        type: string
        default: 'komanatse'
        description: "Registry Docker Hub"
    secrets:
      SSH_HOST:
        required: true
      SSH_USER:
        required: true
      SSH_PRIVATE_KEY:
        required: true
      SSH_PASSPHRASE:
        required: false
      DOCKERHUB_TOKEN:
        required: true
      ENV_CONTENT:
        required: true

jobs:
  get-version:
    name: Get Version Tag
    runs-on: ubuntu-latest
    outputs:
      version_tag: ${{ steps.get-tag.outputs.version_tag }}
    steps:
      - name: Get version tag from build workflow
        id: get-tag
        uses: actions/github-script@v7
        with:
          script: |
            // RÃ©cupÃ©rer le dernier run du workflow de build
            const workflows = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: '${{ inputs.build_workflow_name }}.yml',
              status: 'success',
              per_page: 1
            });
            
            if (workflows.data.workflow_runs.length > 0) {
              const run = workflows.data.workflow_runs[0];
              // RÃ©cupÃ©rer les artifacts ou utiliser la date du run
              const date = new Date(run.created_at);
              const dateTag = date.toISOString().slice(0,10).replace(/-/g,'') + '-' + 
                             date.toISOString().slice(11,16).replace(/:/g,'');
              
              // VÃ©rifier si c'est un tag de release
              if (run.head_branch && run.head_branch.match(/^v\d+\.\d+\.\d+$/)) {
                core.setOutput('version_tag', run.head_branch);
              } else {
                core.setOutput('version_tag', `dev-${dateTag}`);
              }
            } else {
              // Fallback: utiliser la date actuelle
              const now = new Date();
              const dateTag = now.toISOString().slice(0,10).replace(/-/g,'') + '-' + 
                             now.toISOString().slice(11,16).replace(/:/g,'');
              core.setOutput('version_tag', `dev-${dateTag}`);
            }

  deploy:
    name: Deploy to ${{ inputs.environment }}
    needs: get-version
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ inputs.ssh_port }}
          script: |
            set -e
            
            SERVICE_NAME="${{ inputs.service_name }}"
            DEPLOY_PATH="${{ inputs.deploy_path }}"
            COMPOSE_FILE="${{ inputs.compose_file }}"
            VERSION_TAG="${{ needs.get-version.outputs.version_tag }}"
            STACK_NAME="${{ inputs.stack_name }}"
            REGISTRY="${{ inputs.registry }}"
            
            # Si stack_name n'est pas dÃ©fini, utiliser service_name sans "service"
            if [ -z "$STACK_NAME" ]; then
              STACK_NAME=$(echo "$SERVICE_NAME" | sed 's/service$//')
            fi
            
            echo "ðŸš€ DÃ©ploiement de $SERVICE_NAME sur ${{ inputs.environment }}"
            echo "ðŸ“¦ Version: $VERSION_TAG"
            echo "ðŸ“ Stack: $STACK_NAME"
            
            # Aller dans le rÃ©pertoire de dÃ©ploiement
            cd "$DEPLOY_PATH"
            
            # CrÃ©er/Mettre Ã  jour le fichier .env
            cat > .env << 'ENVEOF'
            ${{ secrets.ENV_CONTENT }}
            ENVEOF
            
            # Ajouter DOCKER_TAG au .env
            echo "DOCKER_TAG=$VERSION_TAG" >> .env
            
            # Login Docker Hub
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "$REGISTRY" --password-stdin
            
            # Pull les nouvelles images
            echo "ðŸ“¥ Pull des images..."
            docker compose -f "$COMPOSE_FILE" pull --quiet
            
            # GÃ©nÃ©rer le fichier rÃ©solu compatible Swarm
            echo "âš™ï¸ GÃ©nÃ©ration du fichier Swarm..."
            docker compose -f "$COMPOSE_FILE" config | \
              sed 's/published: "\([0-9]*\)"/published: \1/g' | \
              sed '/host_ip:/d' | \
              sed '/^name:/d' > /tmp/stack-resolved.yml
            
            # DÃ©ployer/Mettre Ã  jour la stack
            echo "ðŸ”„ DÃ©ploiement de la stack..."
            docker stack deploy \
              -c /tmp/stack-resolved.yml \
              --with-registry-auth \
              --prune \
              "$STACK_NAME"
            
            # Nettoyer
            rm -f /tmp/stack-resolved.yml
            
            echo "âœ… $SERVICE_NAME dÃ©ployÃ© avec succÃ¨s sur ${{ inputs.environment }}"
            
            # Afficher le statut
            echo ""
            echo "ðŸ“Š Statut des services:"
            sleep 5
            docker service ls --filter "name=${STACK_NAME}_"
            
            # Nettoyer les anciennes images
            docker image prune -f || true

  health-check:
    name: Health Check
    needs: [get-version, deploy]
    runs-on: ubuntu-latest
    steps:
      - name: Wait for services to stabilize
        run: sleep 30
      
      - name: Check service health
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ inputs.ssh_port }}
          script: |
            SERVICE_NAME="${{ inputs.service_name }}"
            STACK_NAME="${{ inputs.stack_name }}"
            
            # Si stack_name n'est pas dÃ©fini, utiliser service_name sans "service"
            if [ -z "$STACK_NAME" ]; then
              STACK_NAME=$(echo "$SERVICE_NAME" | sed 's/service$//')
            fi
            
            echo "ðŸ¥ VÃ©rification de santÃ© de $STACK_NAME..."
            
            # VÃ©rifier que tous les services sont healthy
            UNHEALTHY=$(docker service ls --filter "name=${STACK_NAME}_" --format "{{.Name}} {{.Replicas}}" | grep -v "1/1\|2/2\|0/0" || true)
            
            if [ -n "$UNHEALTHY" ]; then
              echo "âš ï¸ Services en problÃ¨me:"
              echo "$UNHEALTHY"
              
              # Afficher les logs des services en erreur
              echo "$UNHEALTHY" | awk '{print $1}' | while read svc; do
                echo "--- Logs de $svc ---"
                docker service logs --tail 50 "$svc" 2>&1 || true
              done
              
              exit 1
            fi
            
            echo "âœ… Tous les services de $STACK_NAME sont healthy"

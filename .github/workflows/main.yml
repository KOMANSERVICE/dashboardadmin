name: BACKENDADMIN - Deploy images to prod

on:
  workflow_run:
    workflows: ["BACKENDADMIN - Build and Push Docker Images"]  # nom exact du workflow prÃ©cÃ©dent
    types:
      - completed  # se dÃ©clenche quand le workflow prÃ©cÃ©dent est terminÃ©

env:
  DEPLOY_PATH: /home/komanatse/backendadmin

jobs:
  deploy:
    if: >
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'success' &&
      startsWith(github.event.workflow_run.head_branch, 'v')
    name: Deploy to VPS PROD (auto-tag)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # DÃ©terminer le tag Docker Ã  dÃ©ployer
      - name: Define image tag
        id: vars
        run: |
          set -e

          BRANCH="${{ github.event.workflow_run.head_branch }}"
          REF="${{ github.event.workflow_run.head_sha }}"

          echo "ðŸ” Workflow build triggered on branch/tag: $BRANCH"

          # Si c'est un tag versionnÃ© (vX.X.X)
          if [[ "$BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "env=prod" >> $GITHUB_OUTPUT
            echo "tag=$BRANCH" >> $GITHUB_OUTPUT
            echo "âœ… DÃ©ploiement PROD : $BRANCH"
          else
            echo "env=nonprod" >> $GITHUB_OUTPUT
            echo "ðŸ§ª DÃ©ploiement de la derniÃ¨re version non-prod"

            # RÃ©cupÃ©rer le dernier tag 'dev-' pushÃ© sur GHCR pour l'image API
            IMAGE_NAME="backendadmin"
            GH_API="https://hub.docker.com/v2/repositories/komanatse/${IMAGE_NAME}/tags?page_size=100"

            echo "ðŸ” Recherche du dernier tag 'dev-' pour ${IMAGE_NAME} sur GHCR..."
            TAG=$(curl -s  $GH_API | jq -r '.results[].name' | grep '^dev-' | sort -r | head -n 1)

            if [ -z "$TAG" ]; then
              echo "âŒ Aucun tag 'dev-' trouvÃ© sur GHCR. Abandon."
              exit 1
            fi

            echo "tag=$TAG" >> $GITHUB_OUTPUT
            echo "âœ… Dernier tag dev trouvÃ© : $TAG"
          fi

      - name: Copy docker-compose and .env to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST_PROD }}
          username: ${{ secrets.SSH_USER_PROD }}
          key: ${{ secrets.SSH_PRIVATE_KEY_PROD }}
          passphrase: ${{ secrets.SSH_PASSPHRASE_PROD }}
          port: 22
          source: "docker-compose.prod.yml"
          target: ${{ env.DEPLOY_PATH }}

      - name: SSH to VPS and deploy stack
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST_PROD }}
          username: ${{ secrets.SSH_USER_PROD }}
          key: ${{ secrets.SSH_PRIVATE_KEY_PROD }}
          passphrase: ${{ secrets.SSH_PASSPHRASE_PROD }}
          port: 22
          script: |
            TAG="${{ steps.vars.outputs.tag }}"
            DIR_PATH="${{ env.DEPLOY_PATH }}"

            echo "ðŸ“¦ DÃ©ploiement avec le tag Docker : ${TAG}"

            cd $DIR_PATH

            echo "ðŸ›‘ ArrÃªt des anciens conteneurs"
            docker compose -f docker-compose.prod.yml down

            echo "ðŸš€ Sauvegarde des volumes Docker"
            chmod +x /home/komanatse/savevolume/backup_docker_volumes.sh
            /home/komanatse/savevolume/backup_docker_volumes.sh

            ENV_PATH="$DIR_PATH/.env"
            if [ -f "$ENV_PATH" ]; then
              TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
              mv "$ENV_PATH" "${ENV_PATH}_${TIMESTAMP}.bak"
              echo "ðŸŒ€ Fichier .env renommÃ© : ${ENV_PATH}_${TIMESTAMP}.bak"
            fi

            cat <<EOF > $ENV_PATH
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD_PROD }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB_PROD }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER_PROD }}
            VAULT_URI=${{ secrets.VAULT_URI }}
            VAULT_ROLE_ID=${{ secrets.VAULT_ROLE_ID }}
            VAULT_SECRET_ID=${{ secrets.VAULT_SECRET_ID }}
            VAULT_MOUNT_POINT=${{ secrets.VAULT_MOUNT_POINT }}

            JWT_VALID_AUDIENCE_API=${{ secrets.JWT_VALID_AUDIENCE_API }}
            JWT_VALID_ISSUER_API=${{ secrets.JWT_VALID_ISSUER_API }}
            JWT_SECRET_API=${{ secrets.JWT_SECRET_API }}
            VAULT_PATH_MOUNT_POINT=${{ secrets.VAULT_PATH_MOUNT_POINT }}
            VAULT_EMAIL_ADMIN=${{ secrets.VAULT_EMAIL_ADMIN }}
            VAULT_PASSWORD_ADMIN=${{ secrets.VAULT_PASSWORD_ADMIN }}
            CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS }}
            CONNECTION_STRING_API=${{ secrets.CONNECTION_STRING_API }}
            MENU_SERVICE_URL=${{ secrets.MENU_SERVICE_URL }}
            API_SETTINGS_URL=${{ vars.API_SETTINGS_URL }}
            VAULT_PATH_MOUNT_POINT_MENU=${{ secrets.VAULT_PATH_MOUNT_POINT_MENU }}
            DOCKER_TAG=$TAG
            EOF

            chmod 644 $ENV_PATH
            dos2unix $ENV_PATH

            mkdir -p $DIR_PATH/FrontendAdmin/FrontendAdmin.Web.Client/wwwroot
            mkdir -p $DIR_PATH/FrontendAdmin/FrontendAdmin.Web
            
            cat <<EOF > $DIR_PATH/FrontendAdmin/FrontendAdmin.Web.Client/wwwroot/appsettings.json
            {
              "Logging": {
                "LogLevel": {
                  "Default": "Information",
                  "Microsoft.AspNetCore": "Warning"
                }
              },
              "AllowedHosts": "*",
              "ApiSettings": {
                "Uri": "${{ vars.API_SETTINGS_URL }}"
              }
            }
            EOF
            
            cat <<EOF > $DIR_PATH/FrontendAdmin/FrontendAdmin.Web/appsettings.json
            {
              "Logging": {
                "LogLevel": {
                  "Default": "Information",
                  "Microsoft.AspNetCore": "Warning"
                }
              },
              "AllowedHosts": "*",
              "ApiSettings": {
                "Uri": "${{ vars.API_SETTINGS_URL }}"
              }
            }
            EOF

            echo "ðŸ”‘ Login GHCR"
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            echo "ðŸ“¦ Pull des images version ${TAG}"
            docker compose -f docker-compose.prod.yml pull

            echo "ðŸš€ DÃ©marrage du stack avec le tag ${TAG}"
            DOCKER_TAG=$TAG docker compose -f docker-compose.prod.yml --env-file .env up -d --build --remove-orphans

            echo "âœ… DÃ©ploiement terminÃ© avec succÃ¨s (tag=${TAG})"
